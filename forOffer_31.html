<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script type="text/javascript">
        // https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/
        /**
     * @param {number[]} pushed
     * @param {number[]} popped
     * @return {boolean}
     */
        var foundIt = false;
        var validateStackSequences = function (pushed, popped) {
            foundIt = false;
            dp(pushed, popped, []);
            return foundIt;
        };

        var dp = function (pushed, popped, queue) {
            if (foundIt) return;
            if (popped.length == 0 && popped.length == 0 && queue.length == 0) {
                foundIt = true;
                return
            }

            // 4 种可能
            if (pushed.length == 0) {
                if (popped.length == queue.length) {
                    // 可以 pop 吗？
                    if (popped[0] == queue[queue.length - 1]) {
                        var head = popped.shift();
                        var tail = queue.pop();
                        dp(pushed, popped, queue);
                        popped.unshift(head);
                        queue.push(tail);
                    } else {
                        return
                    }
                } else {
                    return;
                }
            } else if (popped.length == 0) {
                return
            } else {
                // 如果基于每次个场景只有一种情况是可选，那么不一定要每次尝试 push，只有不能 pop 的情况，才才尝试 push

                // 是否可 pop
                if (popped[0] == queue[queue.length - 1]) {
                    var head = popped.shift();
                    var tail = queue.pop();
                    dp(pushed, popped, queue);
                    // 考虑到只有一种操作，也不需要还原现场了。
                    // 但是递归，导致 内存消耗太大
                    // popped.unshift(head);
                    // queue.push(tail);
                } else {
                    // 先执行 push,总是可以 push 的
                    var head = pushed.shift();
                    queue.push(head);
                    dp(pushed, popped, queue);
                    // pushed.unshift(head);
                    // queue.pop();
                }
            }
        };

        var pushed = [285, 807, 202, 706, 847, 959, 221, 392, 868, 304, 427, 12, 449, 41, 956, 458, 240, 251, 132, 88, 67, 993, 111, 971, 854, 866, 557, 630, 174, 622, 296, 727, 661, 838, 489, 399, 256, 367, 58, 37, 269, 494, 243, 49, 138, 819, 397, 7, 450, 948, 317, 369, 842, 96, 275, 982, 402, 35, 13, 892, 209, 398, 780, 880, 224, 291, 218, 196, 751, 315, 491, 690, 355, 173, 220, 583, 246, 91, 757, 836, 363, 617, 376, 749, 282, 417, 188, 197, 746, 428, 705, 619, 194, 527, 61, 276, 599, 984, 80, 883, 584, 593, 257, 320, 592, 129, 620, 189, 893, 47, 168, 502, 668, 212, 897, 368, 563, 495, 193, 360, 73, 822, 697, 643, 395, 724, 857, 621, 578, 550, 15, 914, 379, 81, 881, 65, 575, 200, 141, 754, 34, 29, 691, 831, 284, 232, 990, 394, 281, 431, 840, 56, 907, 50, 598, 745, 882, 872, 851, 545, 684, 633, 3, 818, 38, 161, 680, 865, 234, 307, 919, 486, 788, 150, 911, 902, 59, 136, 325, 17, 997, 78, 322, 895, 127, 711, 704, 765, 299, 344, 955, 137, 646, 117, 658, 553, 568, 411, 848, 439, 130, 613, 114, 74, 195, 266, 82, 998, 371, 422, 172, 811, 535, 712, 493, 805, 233, 655, 470, 886, 131, 148, 475, 350, 461, 601, 972, 707, 603, 742, 888, 964, 94, 862, 995, 577, 522, 769, 561, 967, 741, 101, 456, 293, 764, 877, 386, 164, 451, 572, 289, 330, 650, 716, 974, 806, 909, 253, 624, 242, 512, 905, 311, 286, 812, 180, 915, 44, 963, 546, 801, 181, 421, 708, 133, 587, 353, 700, 672, 359, 294, 814, 27, 346, 891, 389, 944, 542, 2, 140, 515, 698, 839, 254, 787, 900, 323, 245, 809, 692, 614, 610, 335, 644, 721, 939, 703, 408, 166, 896, 654, 940, 19, 107, 415, 949, 46, 576, 11, 874, 435, 438, 455, 104, 487, 318, 803, 418, 292, 115, 929, 927, 856, 558, 508, 669, 701, 732, 815, 248, 958, 213, 772, 444, 149, 26, 146, 79, 477, 414, 273, 777, 42, 184, 791, 403, 953, 198, 762, 722, 714, 770, 830, 916, 155, 429, 412, 792, 407, 642, 316, 947, 490, 934, 926, 24, 702, 18, 237, 351, 723, 347, 87, 629, 798, 560, 238, 500, 145, 810, 365, 850, 901, 952, 25, 329, 14, 496, 448, 113, 480, 795, 920, 466, 77, 618, 666, 941, 72, 89, 454, 555, 207, 85, 912, 8, 128, 22, 290, 913, 675, 845, 544, 308, 425, 607, 889, 594, 596, 441, 440, 623, 279, 396, 612, 778, 64, 186, 357, 903, 564, 139, 267, 445, 978, 638, 973, 887, 606, 586, 635, 156, 632, 720, 375, 534, 108, 268, 406, 153, 531, 183, 802, 908, 609, 160, 876, 552, 921, 731, 864, 543, 157, 756, 277, 869, 789, 21, 260, 511, 504, 761, 100, 608, 485, 381, 885, 686, 83, 92, 126, 498, 968, 280, 373, 709, 270, 326, 681, 305, 252, 147, 433, 226, 639, 782, 808, 719, 337, 910, 671, 356, 965, 274, 453, 820, 530, 922, 339, 432, 517, 688, 565, 747, 503, 656, 752, 52, 977, 331, 969, 518, 516, 158, 54, 917, 979, 334, 30, 554, 837, 39, 278, 951, 227, 574, 97, 591, 771, 93, 262, 991, 159, 340, 75, 264, 62, 472, 631, 988, 538, 9, 342, 84, 142, 821, 387, 682, 483, 90, 513, 651, 469, 841, 297, 855, 488, 391, 526, 151, 871, 954, 208, 492, 446, 687, 228, 510, 235, 154, 263, 204, 790, 229, 898, 863, 272, 961, 781, 241, 678, 750, 5, 324, 380, 301, 20, 86, 505, 604, 354, 71, 833, 521, 775, 170, 738, 923, 298, 559, 843, 728, 319, 976, 931, 679, 641, 401, 222, 60, 302, 447, 653, 364, 464, 540, 236, 734, 176, 306, 825, 884, 637, 40, 713, 580, 928, 423, 201, 144, 478, 121, 590, 925, 43, 626, 628, 352, 23, 647, 597, 605, 383, 942, 225, 348, 1, 804, 169, 548, 271, 853, 206, 846, 648, 717, 258, 497, 844, 985, 424, 501, 105, 739, 933, 217, 588, 116, 676, 390, 759, 551, 99, 171, 434, 852, 773, 683, 374, 123, 103, 471, 817, 482, 384, 382, 861, 473, 566, 938, 693, 0, 362, 66, 573, 824, 890, 970, 649, 135, 419, 185, 16, 465, 835, 996, 476, 223, 214, 616, 310, 729, 615, 358, 823, 571, 813, 828, 570, 987, 899, 547, 48, 849, 219, 834, 677, 663, 63, 165, 314, 694, 481, 743, 776, 737, 328, 736, 541, 499, 519, 210, 6, 529, 205, 980, 430, 794, 710, 785, 175, 962, 187, 943, 393, 600, 748, 645, 562, 118, 463, 388, 250, 536, 249, 259, 569, 327, 98, 918, 768, 660, 341, 673, 514, 55, 875, 946, 826, 829, 120, 870, 261, 230, 873, 366, 231, 247, 452, 361, 766, 349, 336, 124, 685, 989, 152, 966, 999, 595, 725, 426, 109, 178, 579, 338, 783, 333, 906, 827, 726, 657, 556, 664, 10, 416, 4, 733, 524, 860, 32, 192, 143, 715, 662, 539, 162, 689, 718, 879, 859, 203, 51, 244, 295, 670, 779, 567, 190, 33, 937, 957, 110, 442, 312, 467, 994, 216, 640, 378, 385, 730, 793, 303, 57, 755, 102, 413, 182, 627, 468, 211, 437, 404, 904, 832, 179, 930, 474, 894, 797, 758, 300, 509, 983, 410, 377, 800, 457, 70, 400, 506, 858, 665, 581, 420, 76, 287, 924, 167, 975, 28, 992, 695, 31, 36, 986, 533, 878, 370, 667, 816, 68, 634, 309, 582, 936, 735, 69, 744, 867, 696, 459, 523, 177, 981, 636, 760, 799, 767, 321, 625, 436, 753, 215, 589, 332, 255, 528, 53, 288, 199, 484, 740, 125, 786, 602, 443, 932, 674, 532, 343, 405, 585, 479, 549, 537, 372, 95, 774, 950, 960, 525, 652, 106, 119, 699, 462, 935, 239, 313, 163, 659, 611, 460, 796, 283, 520, 507, 112, 763, 45, 265, 345, 409, 122, 191, 945, 134, 784]
            , popped = [807, 285, 706, 202, 868, 449, 458, 956, 41, 12, 427, 304, 251, 132, 993, 67, 88, 240, 392, 221, 959, 111, 847, 971, 854, 866, 630, 557, 727, 256, 399, 489, 367, 58, 37, 269, 838, 661, 494, 49, 243, 296, 622, 174, 7, 450, 397, 369, 96, 275, 982, 402, 842, 317, 948, 35, 892, 398, 209, 13, 780, 819, 751, 196, 491, 315, 690, 355, 220, 173, 218, 246, 91, 363, 836, 757, 376, 282, 749, 188, 417, 197, 617, 705, 428, 527, 194, 619, 746, 276, 61, 583, 984, 80, 584, 593, 883, 257, 592, 129, 620, 320, 189, 893, 563, 368, 897, 73, 360, 822, 643, 395, 857, 621, 724, 697, 193, 550, 578, 15, 914, 81, 881, 141, 754, 34, 200, 575, 29, 65, 379, 495, 212, 668, 502, 168, 691, 47, 284, 831, 990, 394, 232, 840, 56, 907, 431, 281, 50, 882, 745, 633, 684, 545, 3, 851, 818, 872, 598, 38, 486, 919, 788, 307, 234, 902, 911, 150, 59, 136, 997, 78, 711, 127, 895, 322, 344, 299, 765, 704, 955, 137, 646, 17, 325, 865, 680, 658, 848, 411, 439, 568, 613, 266, 195, 82, 998, 371, 172, 422, 535, 811, 74, 805, 233, 493, 655, 712, 114, 130, 553, 117, 470, 886, 131, 148, 161, 461, 601, 350, 707, 742, 888, 603, 94, 995, 577, 769, 522, 101, 456, 741, 967, 293, 386, 877, 764, 561, 164, 862, 964, 451, 650, 330, 289, 572, 716, 806, 974, 909, 624, 253, 242, 972, 512, 475, 905, 599, 812, 286, 311, 291, 44, 546, 963, 801, 915, 181, 180, 224, 880, 708, 294, 814, 27, 359, 346, 672, 700, 140, 2, 542, 254, 839, 698, 515, 944, 389, 900, 245, 323, 787, 891, 331, 587, 809, 692, 133, 421, 138, 614, 610, 335, 644, 939, 721, 703, 166, 408, 896, 19, 107, 940, 654, 415, 46, 949, 874, 11, 576, 435, 455, 438, 104, 487, 318, 418, 803, 856, 669, 508, 248, 958, 213, 772, 444, 815, 732, 701, 558, 149, 927, 929, 115, 146, 79, 477, 26, 777, 184, 403, 791, 42, 953, 273, 198, 830, 770, 155, 916, 714, 642, 407, 792, 412, 429, 316, 926, 702, 24, 934, 237, 347, 723, 351, 629, 87, 798, 560, 18, 238, 500, 145, 901, 25, 952, 14, 329, 496, 795, 920, 77, 618, 466, 666, 941, 480, 72, 89, 454, 113, 85, 8, 912, 207, 128, 913, 675, 290, 845, 544, 594, 596, 279, 623, 612, 64, 778, 903, 357, 186, 973, 638, 635, 586, 606, 720, 632, 375, 156, 887, 108, 183, 802, 531, 153, 908, 406, 552, 921, 864, 731, 876, 543, 157, 756, 160, 609, 268, 534, 978, 445, 267, 100, 608, 381, 968, 280, 498, 709, 373, 270, 126, 681, 326, 305, 252, 92, 83, 147, 433, 226, 686, 885, 639, 782, 719, 808, 910, 671, 356, 337, 485, 761, 965, 274, 504, 511, 260, 21, 789, 339, 922, 688, 517, 432, 530, 565, 820, 453, 869, 277, 139, 747, 656, 752, 503, 52, 353, 518, 54, 917, 158, 979, 334, 516, 969, 30, 554, 837, 591, 771, 262, 991, 159, 75, 340, 93, 97, 574, 227, 951, 264, 278, 988, 631, 472, 538, 62, 342, 142, 387, 682, 483, 821, 90, 841, 469, 651, 513, 84, 9, 871, 208, 954, 492, 151, 687, 446, 526, 391, 488, 204, 263, 790, 863, 898, 229, 154, 5, 324, 380, 750, 678, 301, 20, 505, 833, 775, 170, 923, 298, 559, 738, 521, 843, 71, 976, 319, 641, 679, 931, 728, 354, 401, 604, 86, 241, 60, 222, 302, 781, 653, 447, 961, 272, 235, 236, 306, 176, 884, 825, 734, 540, 464, 637, 364, 510, 713, 40, 228, 855, 297, 39, 580, 928, 423, 977, 564, 396, 440, 441, 590, 43, 925, 121, 478, 626, 352, 647, 597, 605, 23, 628, 144, 201, 889, 607, 383, 942, 425, 804, 169, 271, 548, 1, 853, 206, 348, 846, 225, 648, 308, 717, 258, 844, 497, 985, 22, 555, 448, 850, 424, 501, 105, 739, 365, 810, 490, 947, 722, 217, 171, 99, 551, 773, 123, 374, 103, 683, 852, 434, 482, 817, 384, 473, 693, 938, 566, 0, 66, 362, 890, 970, 824, 185, 419, 135, 465, 476, 996, 223, 729, 310, 615, 987, 570, 48, 849, 547, 899, 828, 813, 571, 219, 677, 663, 314, 743, 481, 776, 694, 210, 205, 430, 710, 794, 785, 175, 962, 393, 943, 187, 748, 600, 980, 259, 249, 536, 327, 98, 569, 250, 388, 463, 768, 918, 660, 341, 673, 875, 946, 120, 230, 261, 873, 366, 231, 870, 829, 826, 55, 514, 452, 247, 336, 349, 766, 361, 989, 966, 999, 152, 595, 426, 579, 338, 783, 726, 416, 860, 524, 32, 192, 733, 4, 10, 664, 143, 715, 662, 689, 718, 162, 539, 556, 657, 859, 51, 203, 879, 670, 190, 567, 33, 957, 937, 779, 295, 244, 827, 467, 312, 994, 442, 110, 640, 385, 730, 378, 216, 906, 303, 57, 793, 413, 102, 755, 182, 333, 178, 109, 725, 627, 685, 124, 118, 562, 645, 529, 6, 468, 519, 211, 499, 437, 541, 736, 404, 474, 930, 179, 300, 457, 800, 377, 420, 581, 665, 287, 76, 858, 167, 28, 31, 695, 36, 986, 533, 992, 975, 924, 506, 816, 634, 68, 936, 582, 867, 177, 636, 981, 523, 760, 799, 767, 459, 753, 589, 332, 215, 436, 255, 625, 321, 696, 744, 528, 53, 69, 484, 740, 199, 288, 735, 309, 667, 370, 125, 786, 878, 400, 70, 532, 479, 585, 405, 549, 537, 960, 525, 652, 950, 699, 119, 106, 774, 935, 462, 239, 163, 313, 95, 372, 343, 460, 611, 659, 674, 932, 443, 796, 507, 345, 409, 191, 122, 784, 134, 945, 265, 45, 763, 112, 520, 283, 602, 410, 983, 509, 758, 797, 894, 832, 904, 328, 737, 165, 63, 834, 823, 358, 616, 214, 835, 16, 649, 573, 861, 382, 471, 759, 390, 676, 116, 588, 933, 762, 414, 292];
        // 以上是递归的实现，下面使用循环来做，模拟手动验证的逻辑；这是单层循环的解法
        // 前提： 每次操作都是唯一的；
        var validateStackSequences2 = function (pushed, popped) {
            var queue = [];
            while (pushed.length > 0 || popped.length > 0) {
                if (popped.length > 0 && queue.length > 0 && popped[0] == queue[queue.length - 1]) {
                    // 能 pop 就 pop，否则没机会 pop
                    popped.shift();
                    queue.pop();
                } else {
                    if (pushed.length > 0) {
                        var h = pushed.shift();
                        queue.push(h);
                    } else {
                        break;
                    }
                }
            }
            return queue.length === 0;
        };
        // 用双层循环试试，
        // 前提：考虑到 pop 操作的时机是，只有和 push 栈顶一致时才操作，所以如果不一致，考虑一直 push。
        // 失败了。
        var validateStackSequences3 = function (pushed, popped) {
            var queue = [];
            while (pushed.length > 0 || popped.length > 0) {
                if (popped.length > 0 && queue.length > 0) {
                    while (popped[0] !== queue[queue.length - 1]) {
                        var h = pushed.shift();
                        queue.push(h);
                    }
                    while (popped[0] == queue[queue.length - 1]) {
                        // 能 pop 就 pop，否则没机会 pop
                        popped.shift();
                        queue.pop();
                    }
                } else {
                    return false;
                }
            }
            return queue.length === 0;
        };
        // 前提：考虑到 pop 操作的时机是，只有和 push 栈顶一致时才操作，所以如果不一致，考虑一直 push。
        // 这次的切入点是，1. 不停的 push，遇到 可以 pop 时才 pop； 一定是先 push 完毕，再pop ，因为 push 是 pop 的基础；
        var validateStackSequences4 = function (pushed, popped) {
            var queue = [];
            for (let i = 0; i < pushed.length; i++) {
                const obj = pushed[i];
                if (popped.length > 0 && obj == popped[0]) {
                    // 省去 queue 入栈的操作；
                    popped.shift();
                    // 检查是否还可以继续 pop
                    while (popped.length > 0 && popped[0] == queue[queue.length - 1]) {
                        popped.shift();
                        queue.pop();
                    }
                } else {
                    queue.push(obj);
                }
            }
            // 检查 pop 和 queue 是不是对等的
            if (queue.length !== popped.length) {
                return false;
            } else {
                const len = popped.length;
                for (let i = 0; i < len; i++) {
                    const p = popped[i];
                    const q = queue[len - i - 1];
                    if (p != q) {
                        return false;
                    }
                }
                return true;
            }

        };
        // 参考下别人的做法，只管压栈，以及出栈时的检查，不需要考虑最后的扫尾工作；是方案 4 的进阶版本，主要，不要轻易去 shift，影响性能。
        var validateStackSequences5 = function (pushed, popped) {
            var queue = [];
            var k = 0;// pop 队列的步进
            for (let i = 0; i < pushed.length; i++) {
                const obj = pushed[i];
                queue.push(obj);
                // 先压栈，然后再判断，此处可省去后面的去处理 空push队列的逻辑
                while (popped.length > k && queue[queue.length - 1] == popped[k]) {
                    // 移动 pop 队列，模拟 arr.shift(); 操作
                    k++;
                    queue.pop();
                }
            }

            return k == popped.length;
        };
        // 前面思路的问题都在于，判断是否可行，需要遍历完毕。参考 剑指 offer 的思路；以 pop 队列为准，可以提前判断是否可行
        // 😳，以 pop 、push 为主循环，效果类似的。。。没想到
        var validateStackSequences6 = function (pushed, popped) {
            var queue = [];
            var k = 0;// push 队列的步进
            for (let i = 0; i < popped.length; i++) {
                const p = popped[i];
                // 检查是否 queue 队列包含有可 pop 的对象，如果有弹出；
                // 如果暂时没有需要压栈，直到找到为止，如果没找到，立即返回失败
                while (k < pushed.length && queue[queue.length - 1] !== p) {
                    queue.push(pushed[k++]);
                }

                if (queue[queue.length - 1] !== p) {
                    return false;
                }

                if (queue.length > 0 && queue[queue.length - 1] == p) {
                    queue.pop();
                }
            }

            return 0 == queue.length;
        };
    </script>
</body>

</html>
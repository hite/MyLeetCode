<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script type="text/javascript">
        // 我们首先给出一个迷宫，它的规格是5 * 5，在这里我使用int的二维数组表示迷宫，其中1表示障碍，0表示可以通行的道路，要求从（0，0）坐标走到（4， 4）坐标，并输出走过的坐标路径。
        // https://blog.csdn.net/laughing2333/article/details/49619425
        var maze = [
            [0, 1, 0, 0, 0],
            [0, 1, 0, 1, 0],
            [0, 0, 0, 0, 0],
            [0, 1, 1, 1, 0],
            [0, 0, 0, 1, 0]
        ];
        var maxRow = maze.length, maxColumn = maze[0].length;

        function getValueAt(x, y) {
            return maze[x][y];
        }

        function availableSibling(node, visitedNotes) {
            var ret = [];
            var x = node[0], y = node[1];
            // 上
            if (y - 1 >= 0) {
                if (getValueAt(x, y - 1) === 0) {
                    ret.push([x, y - 1]);
                }
            }
            // 左
            if (x - 1 >= 0) {
                if (getValueAt(x - 1, y) === 0) {
                    ret.push([x - 1, y]);
                }
            }
            // 下
            if (y + 1 < maxRow) {
                if (getValueAt(x, y + 1) === 0) {
                    ret.push([x, y + 1]);
                }
            }
            // 右
            if (x + 1 < maxColumn) {
                if (getValueAt(x + 1, y) === 0) {
                    ret.push([x + 1, y]);
                }
            }
            // 检查是否在已经被访问的路径里
            for (let i = ret.length - 1; i >= 0; i--) {
                const element = ret[i];
                for (let j = 0; j < visitedNotes.length; j++) {
                    const visited = visitedNotes[j];
                    if (element[0] === visited[0] && element[1] === visited[1]) {
                        ret.splice(i, 1);
                        break;
                    }
                }

            }
            return ret;
        }

        function getOut(start, end) {
            if (maze.length == 0 || maze[0].length == 0) {
                return
            }

            var st = [];// 管理所有待验证的节点
            var visitedNotes = [];// 正在探索的路径
            var node = start;
            while (node && !(node[0] == end[0] && node[1] && end[1])) {
                visitedNotes.push(node);

                // 检测是否有可用邻居，如果有选择第一个，其他的压栈
                var siblings = availableSibling(node, visitedNotes);
                if (siblings.length == 0) {
                    visitedNotes.pop()
                    node = st.pop();
                } else {
                    for (let i = siblings.length - 1; i >= 0; i--) {
                        const element = siblings[i];
                        st.push(element);
                    }
                    node = st.pop();
                }
            }
            if (node) {
                visitedNotes.push(node);
            }

            console.log(visitedNotes);
        }

        var start = [0, 0], end = [4, 4];
        getOut(start, end);
    </script>
</body>

</html>